#!/bin/bash
# shellcheck disable=SC2154
# (silence shellcheck wrt $cam1 environment variable)

if [[ $# -lt 4 ]];  then  echo "Format: [narrow=1] [cam1=1] $0 width height framerate ms [us] [output_path]"; exit;  fi
if [[ "$(( $1 % 2 ))" -eq 1 ]];  then echo "width has to be even"; exit;  fi
if [[ "$(( $2 % 2 ))" -eq 1 ]];  then echo "height has to be even"; exit;  fi

# Set up shutter parameter if provided
SHTR=""; if [[ $# -gt 4 ]]; then SHTR="--shutter"; fi

# Set up output path (optional parameter 6)
OUTPUT_BASE="/dev/shm"
if [[ $# -gt 5 ]]; then 
    OUTPUT_PATH="$6"
    OUTPUT_DIR="$(dirname "$OUTPUT_PATH")"
    mkdir -p "$OUTPUT_DIR"
else
    OUTPUT_PATH=""
fi

# Create markers file for LSL synchronization
MARKERS_FILE="/dev/shm/camera_markers.txt"
echo "Starting recording" > "$MARKERS_FILE"

# Check for Bookworm OS
workaround=""; 
if [[ "" != "$(grep '=bookworm' /etc/os-release)" ]]; then 
    workaround="--no-raw"
fi

# Detect Pi version and set device ID
d=10; 
if [[ "" != "$(grep "Revision.*: ...17.$" /proc/cpuinfo)" ]]; then 
    if [[ "$cam1" == "" ]]; then 
        d=10
    else 
        d=11
    fi
fi

# Find and configure the media device
for((m=0; m<=5; ++m))
do
    media-ctl -d /dev/media$m --set-v4l2 "'imx296 $d-001a':0 [fmt:SBGGR10_1X10/${1}x${2} crop:($(( (1440 - $1) / 2 )),$(( (1088 - $2) / 2 )))/${1}x$2]" -v; [ $? -eq 0 ] && break
done

# Check if camera is detected
libcamera-hello --list-cameras ; echo

# Prepare for recording
rm -f /dev/shm/tst.pts

# Setup pipes for frame counting
FIFO="/dev/shm/camera_fifo"
rm -f "$FIFO"
mkfifo "$FIFO"

# Start recording based on Pi version
if [[ "" != "$(grep "Revision.*: ...17.$" /proc/cpuinfo)" ]]
then
    # Raspberry Pi 5 - use rpicam-vid
    if [[ -n "$OUTPUT_PATH" ]]; then
        OUTPUT_FILE="${OUTPUT_PATH}.mp4"
    else
        OUTPUT_FILE="/dev/shm/tst${cam1:+1}.mp4"
    fi
    
    # Start rpicam-vid
    rpicam-vid "$workaround" ${cam1:+--camera 1} \
        --width "$1" --height "$2" \
        --denoise cdn_off --framerate "$3" \
        -t "$4" "$SHTR" "$5" \
        -o "$OUTPUT_FILE" -n 2>&1 | tee "$FIFO" &
    
    PID=$!
    
    # Monitor output for frame markers
    exec 3<"$FIFO"
    frame_num=0
    while read -r line <&3; do
        echo "$line" >&2
        if [[ "$line" == *"frame"* || "$line" == *"Frame"* ]]; then
            frame_num=$((frame_num + 1))
            timestamp=$(date +%s.%N)
            echo "$frame_num $timestamp" >> "$MARKERS_FILE"
        fi
    done &
    
    # Wait for process to finish
    wait $PID
    
    # Run timestamp analysis if tools exist
    if [[ -x ~/venv/bin/python && -f ~/rpicam-apps/utils/timestamp.py ]]; then
        ~/venv/bin/python ~/rpicam-apps/utils/timestamp.py --plot ${narrow:+--narrow} "$OUTPUT_FILE"
    fi
else
    # Older Raspberry Pi - use libcamera-vid with PTS file
    if [[ -n "$OUTPUT_PATH" ]]; then
        OUTPUT_FILE="${OUTPUT_PATH}.h264"
    else
        OUTPUT_FILE="/dev/shm/tst.h264"
    fi
    
    # Start libcamera-vid
    libcamera-vid "$workaround" \
        --width "$1" --height "$2" \
        --denoise cdn_off --framerate "$3" \
        --save-pts /dev/shm/tst.pts -t "$4" "$SHTR" "$5" \
        -o "$OUTPUT_FILE" -n 2>&1 | while read -r line; do
            echo "$line" >&2
            if [[ "$line" == *"frame"* || "$line" == *"Frame"* ]]; then
                frame_num=$((frame_num + 1))
                timestamp=$(date +%s.%N)
                echo "$frame_num $timestamp" >> "$MARKERS_FILE"
            fi
        done
    
    # Run PTS analysis
    if command -v ptsanalyze > /dev/null; then
        rm -f tstamps.csv && ptsanalyze /dev/shm/tst.pts
        
        # Copy PTS data to markers file for LSL sync
        if [[ -f "/dev/shm/tst.pts" ]]; then
            cat "/dev/shm/tst.pts" >> "$MARKERS_FILE"
        fi
    fi
fi

echo "Recording complete. Output saved to: $OUTPUT_FILE" >&2
echo "Frame markers saved to: $MARKERS_FILE" >&2 